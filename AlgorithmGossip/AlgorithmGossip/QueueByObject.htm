<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>





  
  
  
  
  
  <link rel="stylesheet" href="css/stdlayout.css" type="text/css">





  
  
  
  
  
  <link rel="stylesheet" href="css/print.css" type="text/css">





  
  
  
  
  
  <meta content="text/html; charset=gb2312" http-equiv="content-type">





  
  
  
  
  
  <title>伫列 - 使用Java 作物件封装</title>
</head>


<body>





<h3><a href="http://taobao.esmartweb.com/man.htm"># 面试时穿什么着装合适，这里找答案! #</a></h3>




<h1><a href="AlgorithmGossip.htm">Algorithm Gossip:&nbsp;伫列 - 使用Java 作物件封装</a></h1>





<h2>说明</h2>

如果您使用C++或Java等支援物件导向的语言来实作伫列，您可以使用类别的方式来包括伫列的功能，将所有的伫列操作由堆叠物件来处理，一旦包装完成，则使用伫列物件的时候，只要呼叫加入、删除等方法，而无需处理伫列的front、rear或判断是否为空等细节。<br>

<h2>解法</h2>

使用C++与使用Java来作类别包装其实是类似的，在这边我们使用Java实作，因为它的语法看来较简洁；Java虽然没有指标，但可以使用参考（Reference）来达到链结的效果，一个节点的类别包装方式如下：<br>

<div style="margin-left: 40px;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">class Node { </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private int data;&nbsp;&nbsp; // 节点资料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private Node next;&nbsp; // 下一个节点位置 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void setData(int data);&nbsp; // 节点资料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void setNext(Node next);&nbsp; // 下一个节点位置 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public int getData();&nbsp; // 传回节点资料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public Node getNext();&nbsp; // 传回下一个节点位置 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">}</span><br>

</div>

&nbsp;<br>

其中next是个物件参考名称，它可以用来参考至（指向）下一个节点物件的记忆体位置，而伫列类别可以如下包装：<br>

<div style="margin-left: 40px;"><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">class Queue { </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private Node front; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private Node rear; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private String name;&nbsp; // 只是个名称 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 利用建构子建立伫列 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public Queue(); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public Queue(String name); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 插入资料至前端 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void add(int data); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 显示前端资料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void printFront(); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 删除前端资料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void del(); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 列出伫列内容 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void list(); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">

<span style="font-weight: bold; font-family: Courier New,Courier,monospace;">}</span><br>

</div>

&nbsp;<br>

利用物件导向来包装资料结构，虽然在设计时需要花较多的心思，但设计完成之后，日后呼叫使用就简单了，以后您只要注意主程式的逻辑设计就可以了。 <br>


<br>

<h2> 实作</h2>


<ul>

  <li> Java </li>

</ul>


<pre>import java.io.*; <br><br>// 节点 <br>class Node { <br>    private int data;   // 节点资料 <br>    private Node next;  // 下一个节点位置 <br><br>    public void setData(int data) { <br>        this.data = data; <br>    } <br><br>    public void setNext(Node next) { <br>        this.next = next; <br>    } <br><br>    public int getData() { <br>        return data; <br>    } <br><br>    public Node getNext() { <br>        return next; <br>    } <br>} <br><br>// 伫列 <br>class Queue { <br>    private Node front; <br>    private Node rear; <br>    private String name;  // 只是个名称 <br><br>    public Queue() { <br>        this("list"); <br>    } <br><br>    // 利用建构子建立伫列 <br>    public Queue(String name) { <br>        this.name = name; <br>        front = new Node(); <br>        front.setNext(null); <br>        rear = front; <br>    } <br><br>    // 插入资料至顶端 <br>    public void add(int data) { <br>        Node newNode = new Node(); <br><br>        if(front.getNext() == null) <br>            front.setNext(newNode); <br><br>        newNode.setData(data); <br>        newNode.setNext(null); <br>        rear.setNext(newNode); <br>        rear = newNode; <br>    } <br><br>    // 显示前端资料 <br>    public void printFront() { <br>        if(front.getNext() == null) <br>            System.out.print("\n伫列为空！"); <br>        else <br>            System.out.print("\n顶端值：" +  <br>                           front.getNext().getData()); <br>    } <br><br>    // 删除前端资料 <br>    public void del() { <br>        Node tmpNode; <br>    <br>        if(front.getNext() == null) { <br>            System.out.print("\n伫列已空！"); <br>            return; <br>        } <br><br>        tmpNode = front.getNext(); <br>        front.setNext(tmpNode.getNext()); <br>        tmpNode = null;    <br>    } <br><br>    // 列出伫列内容 <br>    public void list() { <br>        Node tmpNode; <br><br>        tmpNode = front.getNext(); <br><br>        System.out.print("\n伫列内容："); <br>        while(tmpNode != null) { <br>            System.out.print(tmpNode.getData() + " "); <br>            tmpNode = tmpNode.getNext(); <br>        } <br>    } <br>}  <br><br>public class Queueshow { <br>    public static void main(String[] args) <br>                                  throws IOException { <br>        int input, select; <br>        BufferedReader buf; <br>        buf = new BufferedReader(<br>                     new InputStreamReader(System.in)); <br><br>        Queue q1 = new Queue("伫列测试"); <br><br>        while(true) {  <br>            System.out.print("\n\n请输入选项(-1结束)："); <br>            System.out.print("\n(1)插入值至伫列"); <br>            System.out.print("\n(2)显示伫列前端"); <br>            System.out.print("\n(3)删除前端值"); <br>            System.out.print("\n(4)显示所有内容"); <br>            System.out.print("\n$c&gt;"); <br><br>            select = Integer.parseInt(buf.readLine()); <br><br>            if(select == -1) <br>                break; <br><br>            switch(select) { <br>                case 1: <br>                    System.out.print("\n输入值："); <br>                    input = Integer.parseInt(buf.readLine()); <br>                    q1.add(input); <br>                    break; <br>                case 2: <br>                    q1.printFront(); <br>                    break; <br>                case 3: <br>                    q1.del(); <br>                    break; <br>                case 4: <br>                    q1.list(); <br>                    break; <br>                default: <br>                    System.out.print("\n选项错误！"); <br>            } <br>        } <br><br>        System.out.println(""); <br>    } <br>}<br>



</pre>

</body>
</html>
